0.使用场景
  不关心执行结果；不实时

1.为什么使用消息队列？
  解耦、异步、削峰

2.如何处理消息丢失？
   确认机制+重试（缺点是MQ吞吐量会下降）
  生产者到MQ丢失：生产者设置成confirm（确认）模式
  MQ自己丢了：    持久化
  消费者丢了：    接收方确认机制

3.如何保证消息不被重复消费？
   消息被消费后，就记录下来（通过唯一标识记录到数据库、Redis等）。再次消费时，先查询记录，有记录就丢掉消息
   
4.如何保证消息的顺序性？
   建一个专用处理有序消息的队列，保证队列内的消息FIFO，只有一个消费者处理这个队列消息

5.消息积压
   consumer挂了。
   	如果积压量小，只需要修复消费者就可以
   
kafka与rabbitmq区别
	kafka吞吐量大，速度快。适合高并发大数据量，低延时，少量数据丢失的场景，比如日志采集
	rabbitmq可靠性好，速度不快
  