jvm怎样判断一个对象是否可回收？
	可达性分析算法：当一个对象到GC Roots没有任何引用链相连时，则此对象可以被回收。
新生代对象何时会进入老年代？
	新生代对象年龄超过一定阈值（默认15）
	大对象
	动态年龄判断：Survivor区的存活对象年龄从小到大进行累加，当累加到 X 年龄时的总和大于 Survivor区空间的50%时		    	 ，那么比X大的都会晋升到老年代
	Survivor区空间不足：MinorGC后存活对象多于一块空Survivor区域，则存活对象进入老年代
FULL GC触发条件：
	1)调用System.gc()，系统建议执行Full GC，但是不必然执行。
	2)老年代空间不足
	3)方法区空间不足
垃圾回收算法
	1.复制算法：用于新生代中对象的回收。基本思路：将内存划分为两块，每次只使用其中的一块，当一块内存用完了，将	   	   	  存活的对象移动到另外一块上面，然后在把已使用过的内存空间一次清理掉
	2.标记清除算法：标记出要回收的对象，标记完后，回收所有被标记的对象
	3.标记整理算法：标记出要回收的对象，让所有存活对象都向一端移动，最后清理掉端边界以外的内存
CMS：以获取最短停顿时间为目标，清理老年代，标记清除（Mark-Sweep）算法，存在内存碎片化问题
	步骤：1) 初始标记：标记GCRoots能直接关联到的对象
	          2)并发标记：进行GC RootsTracing的过程
	          3)重新标记：对第二阶段变动过的对象进行标记
	          4)并发清除
G1：可以设置预期停顿时间，清理整个GC堆，不会产生内存碎片
	从整体看基于标记—整理算法，局部（两个Region之间）是基于复制算法
	新生代回收：和ParNew类似
	混合回收：新生代和老年代都回收，分为4步：
		1) 初始标记：需要stw 2)并发标记  3)最终标记：需要stw
		 4)执行回收：需要stw，会反复执行好多次（停顿一会儿，用户运行一会儿）
	优点：停顿时间短；可以指定最大停顿时间；不会产生内存碎片
	缺点：G1维护记忆集的成本较高，占用大量的内存，带来了更高的执行负载，影响效率