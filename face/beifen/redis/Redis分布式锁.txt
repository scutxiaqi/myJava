锁的实现步骤
	1.加锁成功，则执行业务，最后释放锁
	2.加锁失败，则阻塞，重试，直至加锁成功
简单版
加锁：执行setnx指令，成功执行表示加锁成功，否则就是加锁失败
阻塞：如果加锁失败，需要等待，等待过程中需要不断轮询去尝试加锁（这种方式对redis压力很大）
释放锁：把加锁时设置的key删除掉

存在的问题：
死锁：假如客户端A加锁成功后，机器突然挂了，锁永远释放不了
          解决方案：加锁时设置失效时间
不可重入：加锁的线程不能再次获得锁

加强版：	
加锁：1)先判断锁的key是否存在 
          2)不存在则加锁。值为hash类型：hash的key为客户端id，值为1
          3)如果存在，判断是否是当前客户端加了锁。如果是，则加锁次数累加1。如果不是，则加锁失败
释放锁
	1)每次都对锁的值减1
	2)如果锁的值0，说明客户端已经不再持有锁，删除这个key
	




原理：setnx操作具有原子性，可以保证一个key操作只有一个成功，来获取锁权限；释放锁就是把key删掉；
	 设置失效时间来解决死锁问题
        Redis官方支持原生的分布式锁，采用了RedLock算法，原理如下:
	(1)使用一个key作标记（代表资源），如果客户端使用setnx设置这个key成功，则表示加锁成功。
	(2)释放锁：把这个key删除
       开源框架：Redission提供了分布式锁的支持，RLock是可重入锁的分布式实现，原理：
	Redission原理和Redis原生分布式锁相似，只是使用Lua脚本来保证操作的原子性
       Redis分布式锁缺点：
	如果master宕机，数据还没同步到slave，会导致重复加锁，也就是多个客户端同时获取了同一把锁。

